//go:build gen

package main

import (
	"errors"
	"fmt"
	"go/build"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	errmsg "github.com/siyuan-infoblox/go-imports-group/pkg/errors"
)

func main() {
	stdPkgs, err := getStandardPackages()
	if err != nil {
		log.Fatalf("Failed to get standard packages: %v", err)
	}

	// Generate the std package list file
	if err := generateStdPackageFile(stdPkgs); err != nil {
		log.Fatalf("Failed to generate std package file: %v", err)
	}

	fmt.Printf("Generated standard library package list with %d packages\n", len(stdPkgs))
}

// getStandardPackages discovers all Go standard library packages
func getStandardPackages() ([]string, error) {
	goroot := build.Default.GOROOT
	if goroot == "" {
		return nil, errors.New(errmsg.ErrMsgGORootNotFound)
	}

	srcDir := filepath.Join(goroot, "src")
	var stdPkgs []string

	err := filepath.Walk(srcDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip non-directories
		if !info.IsDir() {
			return nil
		}

		// Get relative path from src directory
		relPath, err := filepath.Rel(srcDir, path)
		if err != nil {
			return err
		}

		// Skip the root src directory
		if relPath == "." {
			return nil
		}

		// Skip internal, vendor, and testdata directories
		if strings.Contains(relPath, "internal") ||
			strings.Contains(relPath, "vendor") ||
			strings.Contains(relPath, "testdata") ||
			strings.HasPrefix(relPath, ".") {
			return filepath.SkipDir
		}

		// Skip directories that don't contain Go files
		hasGoFiles, err := hasGoSourceFiles(path)
		if err != nil {
			return err
		}
		if !hasGoFiles {
			return nil
		}

		// Convert path separators to forward slashes for import paths
		importPath := filepath.ToSlash(relPath)

		// Skip certain packages that are typically not imported directly
		if shouldSkipPackage(importPath) {
			return nil
		}

		stdPkgs = append(stdPkgs, importPath)
		return nil
	})

	if err != nil {
		return nil, err
	}

	// Sort the packages
	sort.Strings(stdPkgs)
	return stdPkgs, nil
}

// hasGoSourceFiles checks if a directory contains any .go files
func hasGoSourceFiles(dir string) (bool, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return false, err
	}

	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".go") &&
			!strings.HasSuffix(entry.Name(), "_test.go") {
			return true, nil
		}
	}
	return false, nil
}

// shouldSkipPackage determines if a package should be skipped
func shouldSkipPackage(importPath string) bool {
	skipPrefixes := []string{
		"cmd/",      // Command-line tools
		"vendor/",   // Vendor directory
		"internal/", // Internal packages
	}

	skipExact := []string{
		"builtin", // Special case - builtin types, not imported
	}

	for _, prefix := range skipPrefixes {
		if strings.HasPrefix(importPath, prefix) {
			return true
		}
	}

	for _, exact := range skipExact {
		if importPath == exact {
			return true
		}
	}

	return false
}

// generateStdPackageFile creates a Go file with the standard library package list
func generateStdPackageFile(stdPkgs []string) error {
	// Get current working directory and construct relative path
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("%s: %w", errmsg.ErrMsgFailedToGetWorkingDir, err)
	}

	outputPath := filepath.Join(cwd, "pkg", "std", "packages.go")

	content := `// Code generated by go run -tags gen ./pkg/std/gen; DO NOT EDIT.

package std

// StandardPackages contains all Go standard library packages
var StandardPackages = map[string]bool{
`

	for _, pkg := range stdPkgs {
		content += fmt.Sprintf("\t%q: true,\n", pkg)
	}

	content += `}

// IsStandardPackage checks if the given import path is a Go standard library package
func IsStandardPackage(importPath string) bool {
	return StandardPackages[importPath]
}
`

	return os.WriteFile(outputPath, []byte(content), 0644)
}
